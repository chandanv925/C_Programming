1. **What are the difference between compilation and execution?**
   - Between compilation and execution, there are several stages involved in preparing and running a program. These stages may vary depending on the programming language, the compiler or interpreter being used, and the target platform. However, in a typical scenario for a compiled language like C or C++, the stages include:

	1. **Preprocessing**: - It replaces macros with their definitions, includes header files, and handles conditional compilation.
	2. **Compilation**:- The preprocessed source code is then compiled into assembly code, compiler checks the syntax and semantics of the code, generates object files (.obj, .o).
	3. **Linking**:- In this stage, the linker combines the object files generated by the compiler into a single executable or shared library.
 	4. **Loading (optional)**:- If the program is dynamically linked, the operating system's loader loads the necessary shared libraries into memory when the program is executed.
	5. **Execution**:- Finally, the operating system creates a new process for the program and begins executing it.

1. **What is the difference between `int` and `float` data types?**
   - `int` is used to store integer values without any fractional part, while `float and double` is used to store floating-point numbers which can represent real numbers with fractional parts. `int and float ` typically occupies  4 bytes a fixed amount of memory, while `double` typically occupies 8 bytes and can represent fractional values. 

2. **Explain the concept of pointers in C.**
   - Pointers in C are variables that store memory addresses as their values. They point to the location of other variables in memory, allowing for direct memory manipulation, dynamic memory allocation, and the creation of data structures like linked lists. Pointers are declared using the `*` symbol and can be dereferenced using the `*` operator. pointer occupies 8 bytes.

4. **What is the purpose of the `sizeof` operator in C?**
   - The `sizeof` operator is used to determine the size, in bytes, of a variable or data type. It's commonly used when allocating memory dynamically or when dealing with arrays to calculate the total memory required.

5. **Explain the difference between `++i` and `i++`.**
   - `++i` is the pre-increment operator, which increments the value of `i` and then returns the incremented value. `i++` is the post-increment operator, which returns the current value of `i` and then increments it.

6. **How does `scanf()` function work in C?**
   - `scanf()` reads formatted input from the standard input and stores the data into variables based on the format provided. It takes format specifiers as arguments to specify the type and format of data to be read.

7. **What is the difference between `scanf()` and `gets()` functions?**
   - `scanf()` reads formatted input from the standard input, allowing you to specify the format of the input. `gets()` reads a string from the standard input until a newline character is encountered.

8. **What is a structure in C? How is it different from an array?**
   - A structure in C is a composite data type that allows you to group together variables of different data types under a single name. Unlike arrays, which store elements of the same data type in contiguous memory locations, structure members can be of different data types and are accessed using dot notation.

9. **Explain the use of `typedef` keyword in C.**
   - The `typedef` keyword in C is used to create aliases for data types, making code more readable and maintainable. For example, `typedef int myInt;` would define `myInt` as an alias for the `int` data type.

10. **What are unions in C?**
    - Unions in C are similar to structures but allocate memory large enough to hold the largest member. However, only one member can be active at any given time. They are used when you need to store different types of data in the same memory location, with only one type being relevant at a time.

11. **Explain the difference between union and struct in C.**
    - A structure (`struct`) in C is a composite data type that allows you to group together variables of different data types under a single name. Each member within a structure has its own memory location. In contrast, a union (`union`) is also a composite data type but it allows different members to share the same memory location. This means that a union variable can only hold the value of one of its members at a time, unlike a structure where each member has its own memory space.

12. **What is a pointer to a function in C? How is it useful?**
    - A pointer to a function in C holds the address of a function in memory. This allows you to call the function indirectly through the pointer. Pointers to functions are useful in scenarios like callback functions, where you want to pass a function as an argument to another function, or in implementing data structures like function pointers in arrays for dynamic dispatch.

13. **Explain the concept of dynamic memory allocation in C.**
    - Dynamic memory allocation in C refers to the process of allocating memory at runtime rather than compile time. It's done using functions like `malloc()`, `calloc()`, or `realloc()` to request memory from the heap. This memory can be resized and freed as needed during program execution.

14. **What are the advantages of using dynamic memory allocation?**
    - Dynamic memory allocation allows you to allocate memory as needed during program execution, which can be particularly useful when the size of data is not known at compile time or when memory requirements vary. It helps in efficient memory management and avoids wastage of memory.

3. **What is the difference between `malloc()` and `calloc()` functions in C?**
   - `malloc()` allocates a block of memory without initializing its contents, while `calloc()` allocates memory and initializes all bytes to zero. `calloc()` requires two arguments - the number of elements to allocate and the size of each element, whereas `malloc()` requires only the total size in bytes.

15. **Explain the difference between `calloc()` and `realloc()` functions.**
    - `calloc()` is used to allocate memory for an array of elements and initializes the memory to zero. It takes two arguments: the number of elements to allocate and the size of each element. On the other hand, `realloc()` is used to resize previously allocated memory. It takes two arguments: a pointer to the previously allocated memory block and the new size.

16. **What is the purpose of the `free()` function in C?**
    - The `free()` function in C is used to deallocate memory that was previously allocated dynamically using functions like `malloc()`, `calloc()`, or `realloc()`. This helps in avoiding memory leaks and efficiently managing memory resources during program execution.
	int *ptr1, *ptr2;
	ptr1 = (int*)malloc(5*sizeof(int));
	ptr2 = (int*)calloc(5, sizeof(int));
	ptr1 = (int*)realloc(ptr1, 6*sizeof(int));
	free(ptr);

17. **What are the qualifiers in c?**
    - Qualifiers are keywords that modify the properties of variables, functions, or pointers. There are several qualifiers used in C, including:
	1. **const**: 
	This qualifier is used to define constants. It tells the compiler that the value of the variable cannot be changed once it has been initialized.
	2. **volatile**: 
	This qualifier is used to indicate that a variable may be changed at any time by external sources such as hardware or other parts of the program that are not 	explicitly written by the programmer. It prevents the compiler from optimizing away reads or writes to that variable.
	3. **restrict**: 
	This qualifier is used to optimize pointer-based operations by informing the compiler that a pointer is the only way to access a particular piece of memory for 	a specific scope. This can help the compiler perform certain optimizations.

27. **What are the different storage classes in C?**
    - The different storage classes in C are `auto`, `register`, `static`, `extern`, and `typedef`. They control the lifetime, scope, and visibility of variables and functions in a C program.

18. **Explain the storage class in C.**
    - In C programming, a storage class specifies the lifetime, visibility, and initial value of variables. There are several storage classes in C, each with its own characteristics:
	1. **auto**: 
	This is the default storage class for local variables. Variables declared with the `auto` storage class are automatically created when the block they are 	declared in is entered and destroyed when the block is exited.
	2. **register**: 
	This storage class is similar to `auto`, but it hints to the compiler that the variable should be stored in a CPU register for faster access. However, the 	compiler is not obligated to comply with this hint.
	3. **static**: 
	Variables declared with the `static` storage class retain their values between function calls. They are initialized only once, and their lifetime extends for 	the entire program execution.
	4. **extern**: 
	This storage class is used to declare a global variable in one file that is defined in another file. It informs the compiler that the variable is defined 	elsewhere.
	5. **thread_local** (C11 and later): 
	This storage class specifies that the variable has a unique instance per thread. Each thread gets its own copy of the variable.
___________________________________________________________________________________________________________________________________________________
| Storage Class | Lifetime                        | Visibility                    | Initial Value                               | Saved in         |
|---------------|---------------------------------|-------------------------------|---------------------------------------------|------------------|
| auto          | Inside the block where          | Limited to the block          | Garbage (not initialized implicitly)        | Stack            |
|               | it is declared (local)          | it is declared (local)        |                                             |                  |
| register      | Inside the block where          | Limited to the block          | Garbage (not initialized implicitly)        | CPU Registers    |
|               | it is declared (local)          | it is declared (local)        |                                             |                  |
| static        | Entire program execution        | Limited to the file           | Zero (if not initialized explicitly)        | Data Segment     |
|               |                                 | it is declared in (global)    |                                             |                  |
| extern        | Entire program execution        | Visible to all files          | Depends on where the variable is defined    | Memory           |
|---------------|                                 |                               |                                             |                  |
| Global        | Entire program execution        | Visible to all files          | Zero (if not initialized explicitly)        | Data Segment     |
|               |                                 |                               |                                             |                  |
| Local         | Inside the block where          | Limited to the block          | Garbage (not initialized implicitly)        | Stack            |
|               | it is declared                  | it is declared                |                                             |                  |
----------------------------------------------------------------------------------------------------------------------------------------------------

53. **What is variable scope in C?**
    - Variable scope in C refers to the region of code where a variable can be accessed. It's determined by where the variable is declared and defines where the variable is visible and can be used within the program.

54. **What is global and local variable in C?**
    - Global variables in C are declared outside of any function and can be accessed from any part of the program. Local variables are declared inside functions and are only accessible within the function in which they are declared.

55. **Explain the difference between automatic, static, and register variables in C.**
    - Automatic variables are local variables that are created when a function is called and destroyed when the function exits. Static variables retain their value between function calls and are initialized only once. Register variables are stored in CPU registers for faster access but their usage is often ignored by modern compilers.

56. **What is the purpose of `static` keyword when used with a function?**
    - When used with a function, the `static` keyword in C limits the visibility of the function to the file in which it is defined. It essentially makes the function "private" to that file, preventing it from being accessed by functions in other files linked together.


19. **What is recursion? How is it implemented in C?**
    - Recursion is a programming technique where a function calls itself directly or indirectly in order to solve a problem. In C, recursion is implemented by defining a function that calls itself within its definition. Recursive functions have a base case that terminates the recursion and one or more recursive cases that call the function with modified arguments.

20. **Explain the concept of pass by value and pass by reference in C.**
    - In pass by value, a copy of the actual parameter is passed to the function. Any modifications made to the parameter inside the function do not affect the original variable. In pass by reference, the address of the actual parameter is passed to the function, allowing the function to modify the original variable directly. Pointers are often used to achieve pass by reference in C.

void incrementByAddress(int *ptr) {      //C & CPP
    (*ptr)++;
}
void incrementByReference(int &ref) {	// only in CPP
    ref++;
}
int main() {
    int num1 = 5, num2 = 10;
    incrementByAddress(&num1);
    incrementByReference(num2);
}

21. **What is a constant pointer? How is it different from a pointer to a constant?**
    - A constant pointer is a pointer whose value (i.e., the memory address it holds) cannot be changed after initialization. On the other hand, a pointer to a constant is a pointer that can change its memory address but cannot modify the value at that address. So, the difference lies in what is constant - the pointer itself or the value it points to.

22. **What is a NULL pointer in C? How is it different from a void pointer?**
    - A NULL pointer in C is a pointer that doesn't point to any memory location. It's often used to indicate that the pointer is not currently pointing to a valid object. A void pointer, on the other hand, is a pointer that has no associated data type information. It can point to any type of data but cannot be dereferenced directly without casting.

23. **How do you declare a multidimensional array in C?**
    - In C, a multidimensional array is declared by specifying the dimensions for each level of the array. For example, `int arr[3][4];` declares a 2-dimensional array with 3 rows and 4 columns. Arrays with more than two dimensions follow the same pattern, where each dimension is specified within the square brackets.

30. **How do you define a macro in C?**
    - Macros in C are defined using the `#define` directive followed by the macro name and its replacement text. For example, `#define PI 3.14159` defines a macro named PI with the value 3.14159.
Ex -
#define PI 3.14159
#define MAX(x, y) (x > y ? x : y)

31. **What is a preprocessor directive? Give examples.**
    - Preprocessor directives in C are commands that are processed by the preprocessor before compilation. Examples include `#include`, `#define`, `#ifdef`, `#ifndef`, `#endif`, etc.

32. **Explain the difference between `#define` and `const` in C.**
    - `#define` is a preprocessor directive used to define macros, whereas `const` is a keyword used to define constants. `#define` macros are simple text substitutions and lack type checking, while `const` constants have a specific data type and are stored in memory.

33. **What is the ternary operator in C? How is it used?**
    - The ternary operator `? :` is a conditional operator in C that takes three operands: a condition, a value to return if the condition is true, and a value to return if the condition is false. It is used as a shorthand for `if-else` statements.

34. **Explain the concept of bitwise operators in C.**
    - Bitwise operators in C operate on individual bits of integer operands. They include AND `&`, OR `|`, XOR `^`, complement `~`, left shift `<<`, and right shift `>>`. They are often used for low-level manipulation of data, such as setting or clearing specific bits.

35. **What are left shift and right shift operators in C?**
    - Left shift `<<` and right shift `>>` operators in C move the bits of an integer operand to the left or right by a specified number of positions, respectively. They are equivalent to multiplication and division by powers of 2.

36. **Explain the difference between `&&` and `||` operators in C.**
    - `&&` is the logical AND operator, which returns true if both operands are true. `||` is the logical OR operator, which returns true if at least one of the operands is true.

37. **What is short circuit evaluation in C?**
    - Short circuit evaluation in C refers to the behavior where the evaluation of a logical expression stops as soon as the final result can be determined. For example, in the expression `a && b`, if `a` evaluates to false, `b` is not evaluated because the result of the expression is already known to be false.

38. **What is the purpose of `break` and `continue` statements in C?**
    - The `break` statement is used to exit from a loop or switch statement prematurely, while the `continue` statement is used to skip the rest of the loop body and jump to the next iteration.

39. **Explain the difference between `while` and `do-while` loops in C.**
    - In a `while` loop, the condition is evaluated before the loop body is executed, so the loop body may not execute at all if the condition is false initially. In a `do-while` loop, the condition is evaluated after the loop body is executed, guaranteeing that the loop body executes at least once.
	
39. **Explain the`do-while` loops in C.**
	
	#include <stdio.h>
	void sumNumbers() {
		int sum = 0;
		int number;

		// do-while loop to ensure the block runs at least once
		do {
			printf("Enter a number (0 to end): ");
			scanf("%d", &number);
			sum += number;
		} while (number != 0); // Continue the loop until the user enters 0
	
		printf("The total sum is: %d\n", sum);
	}
	
	int main() {
		sumNumbers();
		return 0;
	}

40. **What is a nested loop? How is it used?**
    - A nested loop is a loop inside another loop. It's used when you need to perform repetitive tasks that require iterating over multiple dimensions or structures, 
such as 2D arrays, matrix operations, or traversing tree-like structures. Each iteration of the outer loop triggers the inner loop to execute its complete cycle.

41. **Explain the concept of goto statement in C. Is it recommended to use goto in programs?**
    - The `goto` statement in C allows transferring control to another part of the program based on a label. While it can be useful for certain situations like breaking out of nested loops or handling errors in complex functions, it is generally not recommended to use `goto` because it can lead to spaghetti code and make the program harder to understand and maintain.

42. **How do you write a switch statement in C? What are its limitations?**
    - A switch statement in C allows you to execute different blocks of code based on the value of an expression. It's written as:
      ```c
      switch (expression) {
          case constant1:
              // code block
              break;
          case constant2:
              // code block
              break;
          // more cases...
          default:
              // code block
      }
      ```
      Limitations include the requirement that cases must be constants, cannot compare strings directly, and only one case block executes even if multiple cases match.

43. **What is the purpose of `enum` keyword in C?**
    - The `enum` keyword in C is used to define an enumeration type, which is a user-defined data type consisting of a set of named constants. It provides a way to create symbolic names for integers, improving code readability and maintainability.

45. **What is a self-referential structure in C?**
    - A self-referential structure in C is a structure that contains a pointer to another variable of the same type as one of its members. It's commonly used to implement linked lists, trees, and other recursive data structures.

      struct MyStruct {
          int member1;
          float member2;
          struct MyStruct *ptr;
      };

49. **Explain the purpose of `sizeof` operator when used with structures.**
    - When used with structures, the `sizeof` operator in C returns the size, in bytes, of the entire structure. This is useful for dynamically allocating memory for structures and for determining the memory footprint of structures in memory.

50. **What are function prototypes in C? Why are they necessary?**
    - Function prototypes in C declare the function signature (return type, name, and parameters) before the function definition or usage. They inform the compiler about the existence and interface of the function, allowing it to perform type checking and ensure correct usage of functions throughout the program.

57. **How do you use command line arguments in C?**
    - Command line arguments in C are passed to the `main` function as parameters. `argc` stores the number of arguments passed, and `argv` is an array of strings containing the actual arguments.

58. **Explain the purpose of `argc` and `argv` parameters in `main` function.**
    - `argc` is an integer that holds the number of command-line arguments passed to the program. `argv` is an array of strings (`char*`) where each element is one of the arguments passed to the program.

```c

int main(int argc, char *argv[]) {
    // Print the number of command-line arguments
    printf("Number of arguments: %d\n", argc);

    // Print each command-line argument
    for (int i = 0; i < argc; i++) {
        printf("Argument %d: %s\n", i, argv[i]);
    }

    return 0;
}
```

```
./program_name arg1 arg2 arg3
```

Output:
```
Number of arguments: 4
Argument 0: ./program_name
Argument 1: arg1
Argument 2: arg2
Argument 3: arg3
```

59. **What is a file pointer in C? How is it different from a regular pointer?**
    - A file pointer in C is a special type of pointer used to reference a file stream. It is used for reading from or writing to files. Unlike regular pointers, file pointers are created and managed by the C standard library, and they are used with functions like `fopen`, `fclose`, `fread`, `fwrite`, etc.

61. **What are the different modes in which a file can be opened in C?**
    - Files in C can be opened in different modes depending on the intended operations. Some common modes include:
      - `"r"`: Open for reading.
      - `"w"`: Open for writing. Creates a new file or truncates an existing file to zero length.
      - `"a"`: Open for appending. Writes to the end of the file.
      - `"r+"`: Open for both reading and writing.
      - `"w+"`: Open for reading and writing. Creates a new file or truncates an existing file to zero length.
      - `"a+"`: Open for reading and appending.
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    
	FILE *file;
    char buffer[100];

    file = fopen("example.txt", "w");
    if (file == NULL) {
        perror("Error opening file for writing");
        return EXIT_FAILURE;
    }

    fprintf(file, "Hello, World!\n");
    fprintf(file, "This is a test file.\n");

    fclose(file);

    file = fopen("example.txt", "r");
    if (file == NULL) {
        perror("Error opening file for reading");
        return EXIT_FAILURE;
    }

    while (fgets(buffer, sizeof(buffer), file) != NULL) {
        printf("%s", buffer);
    }

    fclose(file);

    return EXIT_SUCCESS;
}
```

63. **How do you read data from a file in C?**
    - Data can be read from a file in C using functions like `fgetc()`, `fgets()`, or `fread()`. These functions read data from the file stream and advance the file pointer to the next position.

64. **How do you write data to a file in C?**
    - Data can be written to a file in C using functions like `fputc()`, `fputs()`, or `fwrite()`. These functions write data to the file stream at the current position and advance the file pointer.

65. **What is the difference between `fputc()` and `putc()` functions in C?**
    - There is no practical difference between `fputc()` and `putc()` functions in C. Both are used to write a character to a file stream. `fputc()` is generally preferred for consistency, as it explicitly mentions the file pointer, while `putc()` is a macro that may be less clear.

66. **How do you use `fgets()` function to read a line from a file?**
    - The `fgets()` function reads a line from a file stream and stores it into a string buffer. It takes three arguments: the buffer to store the line, the maximum number of characters to read, and the file pointer. Example:
      ```c
      char buffer[100];
      fgets(buffer, 100, filePointer);
      ```
67. **Explain the use of `fprintf()` function in C.**
    - The `fprintf()` function is used to write formatted data to a file stream. It works similar to `printf()`, but instead of printing to the standard output, it prints to the specified file stream.

68. **How do you use `fscanf()` function to read formatted input from a file?**
    - The `fscanf()` function reads formatted input from a file stream, similar to `scanf()`, but instead of reading from the standard input, it reads from the specified file stream. Example:
      ```c
      fscanf(filePointer, "%d %f %s", &intValue, &floatValue, stringValue);
      ```

69. **What are binary files and text files in C? How do you differentiate between them?**
    - Binary files contain data in a format that is not human-readable, while text files contain data that is human-readable. Binary files store data in its raw form, while text files store data as ASCII characters. Differentiation is based on how data is stored and manipulated.

70. **Explain the purpose of `feof()` and `ferror()` functions in C.**
    - `feof()` checks if the end-of-file indicator has been set for a file stream. `ferror()` checks if an error has occurred on the file stream. These functions are useful for error handling and for determining when to stop reading from or writing to a file.

71. **What is file positioning in C? How do you use `fseek()` and `ftell()` functions for file positioning?**
    - File positioning in C refers to the ability to move the file pointer to a specific location within a file. `fseek()` is used to set the file position indicator to a specified offset relative to a reference point, and `ftell()` returns the current value of the file position indicator.

72. **What is the purpose of file buffering in C?**
    - File buffering in C is the mechanism of temporarily storing data in memory before reading from or writing to a file. It improves I/O performance by reducing the number of system calls made to read from or write to the file.

73. **Explain the difference between buffered and unbuffered I/O in C.**
    - Buffered I/O involves reading from or writing to a file using a buffer in memory, which improves performance by reducing system calls. Unbuffered I/O, on the other hand, directly reads from or writes to the file without using an intermediate buffer.

74. **How do you use `rewind()` function in C?**
    - The `rewind()` function in C is used to move the file pointer to the beginning of a file. It sets the file position indicator to the beginning of the file, allowing subsequent read or write operations to start from the beginning.

75. **What is command-line input/output redirection in C?**
    - Command-line input/output redirection in C allows you to redirect input from or output to files or other streams using special characters like `<`, `>`, and `|` when running the program from the command line.

76. **Explain the concept of pipe in C. How do you create a pipe?**
    - A pipe in C is a mechanism for interprocess communication, allowing the output of one process to be sent directly to the input of another process. Pipes are created using the `pipe()` function, which creates a pair of file descriptors representing the ends of the pipe.

77. **What is a signal in C programming? How do you handle signals?**
    - A signal in C programming is a notification sent to a process to indicate that a particular event has occurred. Signals can be generated by the operating system or by other processes. You can handle signals using signal handling functions like `signal()` or `sigaction()`.

78. **Explain the use of `signal()` function in C.**
    - The `signal()` function in C is used to specify a signal handler function for a specific signal. It associates a signal with a user-defined function that will be called when the signal is received.

79. **What is the purpose of `kill()` function in C?**
    - The `kill()` function in C is used to send a signal to a process. It allows one process to send a signal to another process, such as terminating it or requesting specific actions.

80. **What are the different types of errors in C?**
    - Errors in C can be categorized into compilation errors, runtime errors, and logical errors. Compilation errors occur during the compilation phase due to syntax or semantic errors. Runtime errors occur during
81. **Explain the difference between syntax errors, runtime errors, and logical errors.**
    - **Syntax errors**: Syntax errors occur during compilation and result from violations of the programming language's syntax rules. These errors prevent the program from being compiled successfully.
    - **Runtime errors**: Runtime errors occur during the execution of the program and result from unforeseen circumstances, such as division by zero, accessing an invalid memory address, or attempting to open a non-existent file.
    - **Logical errors**: Logical errors occur when the program executes successfully but produces incorrect results due to flaws in the algorithm or logic of the program. These errors are often the most challenging to detect and fix because the program runs without crashing.

82. **What is debugging? How do you debug a C program?**
    - Debugging is the process of identifying and fixing errors or bugs in a program. In C programming, debugging typically involves using tools like debuggers, printf statements, and code reviews to locate and rectify issues. Debuggers allow you to step through the code, inspect variables, and analyze program state during execution.

83. **Explain the purpose of assert macro in C programming.**
    - The `assert` macro in C is used to perform runtime assertion checking. It verifies the truth of an expression and terminates the program if the assertion fails, providing a way to catch unexpected conditions during program execution.

84. **What is the purpose of errno variable in C?**
    - The `errno` variable in C is used to report error conditions that occur during library function calls. It is typically set to an error code by library functions when they encounter an error, allowing the calling code to identify and handle the error appropriately.

85. **Explain the use of perror() function in C.**
    - The `perror()` function in C is used to print a descriptive error message corresponding to the current value of `errno`. It takes a string argument as a prefix for the error message and prints the corresponding error message to the standard error stream.

86. **What is a deadlock? How can you prevent deadlocks in a multithreaded program?**
    - A deadlock in concurrent programming occurs when two or more threads are blocked indefinitely because each is waiting for the other to release a resource. Deadlocks can be prevented by implementing techniques such as resource ordering, deadlock detection and recovery, and using synchronization primitives like mutexes and semaphores judiciously.

87. **Explain the purpose of mutex and semaphore in concurrent programming.**
    - Mutexes and semaphores are synchronization primitives used in concurrent programming to control access to shared resources. Mutexes ensure that only one thread can access a resource at a time, while semaphores allow multiple threads to access a resource within specified limits.

88. **What is a race condition in C? How can you avoid race conditions?**
    - A race condition in C occurs when the behavior of a program depends on the relative timing or interleaving of multiple threads or processes accessing shared resources. Race conditions can be avoided by using synchronization techniques such as mutexes, semaphores, or atomic operations to coordinate access to shared resources.

89. **What are threads in C programming? How do you create and manage threads?**
    - Threads in C programming are lightweight processes that execute independently and share the same memory space. Threads are created using library functions like `pthread_create()` and managed using synchronization primitives like mutexes and condition variables to coordinate access to shared resources.

90. **Explain the difference between user-level threads and kernel-level threads.**
    - User-level threads are managed entirely by the user-space thread library without kernel involvement. Kernel-level threads are managed by the operating system kernel and are visible to the kernel scheduler. Kernel-level threads provide better concurrency but may incur more overhead.

91. **What is thread synchronization? How do you achieve thread synchronization in C?**
    - Thread synchronization is the coordination of multiple threads to ensure that they execute in a predictable and orderly manner. Thread synchronization in C is achieved using synchronization primitives like mutexes, semaphores, and condition variables to control access to shared resources and coordinate the execution of threads.

92. **What are thread-safe functions in C?**
    - Thread-safe functions in C are functions that can be safely called by multiple threads simultaneously without causing data corruption or other synchronization issues. Thread-safe functions typically use synchronization primitives internally to protect shared resources.

93. **Explain the concept of parallel programming in C.**
    - Parallel programming in C involves dividing a program into smaller tasks that can be executed concurrently by multiple threads or processes, typically on multi-core processors or distributed computing systems. Parallel programming aims to improve performance by exploiting parallelism and concurrency in the execution of tasks.

94. **What is OpenMP? How do you use OpenMP for parallel programming in C?**
    - OpenMP (Open Multi-Processing) is an API that supports multi-platform shared memory multiprocessing programming in C, C++, and Fortran. It provides compiler directives, library routines, and environment variables to enable parallel programming. OpenMP directives are used to specify parallel regions, loop parallelism, and synchronization.

95. **What are the advantages and disadvantages of multithreading in C?**
    - **Advantages**: Multithreading in C can improve program responsiveness, utilize multiple CPU cores efficiently, and simplify program design by dividing tasks into smaller, more manageable threads.
    - **Disadvantages**: Multithreading can introduce complexity, increase the likelihood of race conditions and deadlocks, and may incur overhead due to thread creation, synchronization, and context switching.

96. **Explain the purpose of `pthread_create()` and `pthread_join()` functions in C.**
    - `pthread_create()` is used to create a new thread, specifying the thread attributes and the function to be executed by the thread. `pthread_join

()` is used to wait for a thread to terminate and obtain its exit status. These functions are part of the POSIX Threads (pthreads) library for thread creation and management in C.

97. **What is the purpose of `pthread_mutex_lock()` and `pthread_mutex_unlock()` functions in C?**
    - `pthread_mutex_lock()` is used to acquire a mutex lock, allowing a thread to safely access a shared resource. `pthread_mutex_unlock()` is used to release the mutex lock, allowing other threads to acquire it. These functions provide mutual exclusion and prevent data races in multithreaded programs.

98. **Explain the concept of deadlock avoidance in multithreading.**
    - Deadlock avoidance in multithreading involves designing thread synchronization mechanisms and resource allocation strategies to prevent the occurrence of deadlocks. Techniques such as resource ordering, deadlock detection, and dynamic resource allocation can be used to avoid deadlocks.

99. **What is message passing in concurrent programming? How do you implement message passing in C?**
    - Message passing in concurrent programming involves communication between threads or processes by exchanging messages. In C, message passing can be implemented using interprocess communication (IPC) mechanisms such as pipes, message queues, sockets, or shared memory, along with synchronization primitives to ensure orderly message exchange.

100. **Explain the purpose of `fork()` function in C. How do you create child processes?**
    - The `fork()` function in C is used to create a new process, known as the child process, which is an exact copy of the parent process. After calling `fork()`, both the parent and child processes continue execution from the point immediately after the `fork()` call, but they have separate memory spaces. The return value of `fork()` determines whether the code is running in the parent or child process.
